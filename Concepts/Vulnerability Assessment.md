# How it Works

The basic process of an automated vulnerability scanner can be described as:

1. Host discovery
2. Port scanning
3. Operating system, service, and version detection
4. Matching the results to a vulnerability database

# CORE CONCEPT:

- Systematic identification of weaknesses (misconfigurations, unpatched software)
- Evaluation of exploitability and potential impact

# KEY POINTS TO CHECK:

1. Target Surface:
   - Open ports/services (nmap -sV)
   - Patch levels (WMI/wmic for Windows, dpkg -l for Linux)
   - Default/weak credentials (hydra, crackmapexec)
   - Misconfigured permissions (sudo -l, Get-GPO)

2. Stealth Considerations:
   * Rate Limiting:
     - Slow scans (nmap -T2)
     - Distribute scans across IPs
   * Traffic Masking:
     - Use common user agents (e.g., Chrome)
     - Proxy through cloud services (AWS/Azure IPs)
     - Fragment packets (nmap -f)
   * Log Avoidance:
     - Prefer API-based checks
     - Clean temp files (e.g., .gnmap outputs)

3. Stability Preservation:
   * Safe Checks:
     - Use --safe flags (nikto)
     - Avoid aggressive scans (-A in nmap) on production
   * Resource Limits:
     - Cap threads (--max-threads 5 in gobuster)
     - Skip brute-force on critical systems
   * Fallback Plans:
     - Test exploits in isolated envs first
     - Prepare rollback scripts

4. Post-Scan Best Practices:
   - Correlate findings with threat models
   - Validate false positives manually
   - Document all actions (keepnote, Dradis)

# PRO TIPS:

▶ Schedule scans during business hours
▶ Use credentialed scans (Nessus/OpenVAS)
▶ Whitelist critical IPs in scanner configs
▶ Prefer authenticated scans over noisy enumeration